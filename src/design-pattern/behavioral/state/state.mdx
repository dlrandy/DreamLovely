# 设计模式之状态模式

**状态模式属于行为设计模式**

当对象内部状态发生变化的时候，它会改变自身行为(同一个动作形式是不一样的)

![markdown](https://images.unsplash.com/photo-1569365788898-f96aa58c27eb?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80"
Abigail Mangum")

###状态机
状态模式和状态机的概念很接近。
状态机的原理就是在任何一个给定的时刻，程序可以处在有限的几个状态里。在任何不同的状态里，程序的行为是不一样的。但是根据当前的装填，程序可以/不可以从一个状态切换到另一个状态。这个切换规则叫做过度，它也是有限的可以预设的。
>  比如，现在有一个Document类，它有三种状态Draft，Moderation，和Published。Document有一个publish的方法，它在每一个状态下的行为都是不一样的：
- 在Draft下，它会将Document的状态变为Moderation
- 在Moderation下，只有管理员将其公布为Published
- 在Published下，什么也不做

状态机通常使用众多的条件(if、switch)来根据当前的状态选择适当的行为。这个状态可以是一组值。

**状态机的问题**
因为它是基于条件(state)展示自身的，一旦加入了更多的state和state的依赖行为。大多数的方法会包含奇怪的条件来根据当前的state选择方法的正确行为。代码会很难维护，因为过度逻辑的改变可能需要改变每一个方法的state条件

**对于状态机的问题，State模式提供了一个解决方案：**
对于一个对象的所有可能状态创建一个class并把所有和这些class相关的行为提取到class中。最初的对象（context）不需要实现所有的行为，只需要存储当前的一个状态对象来描述当前的状态，并代理所有状态相关的操作到那个状态对象。
为了将context过度到另一个状态，使用另一个状态对象替换掉当前的状态对象来描述新状态。前提条件就是所有的状态类实现了同一个接口，然后context使用这个接口来树里这些状态对象。

**state模式和strategy模式很像呢？？？**
对的，但是一个重要的不同在于：状态模式下，不同的state之间能够意识到彼此的然后才能从一个状态过度到另一个状态，而策略模式下，策略之间是不知道的

**举个例子**
智能手机的buttons，会根据当前设备状态的不同来切换不同的行为
1. 在手机解锁的状态下，按button会执行不同的功能
2. 在手机锁屏的状态下，按button只能让你解锁
3. 在手机电量低的时候，按button会有充电提示

### state模式的结构
1. Context对象
	1. 存储实体状态对象
	2. 代理状态相关的工作到状态对象
	3. context通过state接口/抽象类和state对象通信
	4. context暴露一个setter方法来设置新的状态对象
2. State接口/抽象类
	1. 声明状态相关的方法或者状态通用的方法，这些方法应该意识到所有的实体状态
3.  Concrete State类
	1. 实现state接口/抽象类，
	2. 存储context对象，以便获取必要的信息来进行状态过度
4. context和实体state类都可以设置context的下一个状态，并通过替换state对象来进行状态过度




##什么时候使用状态模式？
- 在一个对象根据自身当前的状态不同而行为不同的时候，状态的数量是有限的而且特定的code是经常改变的
 > 对于这种情况，是要把状态特定的code抽成一组不同的class，添加和改变已有的class，不会彼此影响，减少了维护的成本
- 当有一个class充满了大量的条件，根据当前的域的值来改变class的行为的时候
 > 抽离条件分支到对应的state类的方法里，同时也可以清理特定状态的相关的临时域和辅助方法到主类之外
- 在相似的状态里以及基于条件状态机的过度里有大量的重复代码的时候
 > 组合状态类的层级提取公共的代码到抽象的基类里


## 如何实现状态模式？
注意状态模式的几个结构
##具体思路
1. 决定哪个class作为context，它可以是存在的class但是独立于状态；或者是新的class
2. 声明state接口/抽象类。它要映射context里使用方法，但是只是state专有的行为
3. 实际状态类要继承state接口/状态类，查看context的方法将所有和状态相关的code提取到新创建的状态类里
4. 在context类里，添加state接口/抽象类的引用并提供setter方法用来修改state
5. 遍历context的方法使用对象的状态方法替换掉状态条件
6. 为了能够切换context的状态，创建一个state实例传递到context里， context要和实体state独立

##什么时候不需要使用状态模式？
如果一个状态机只有几个状态而且不怎么变化，就不需要

##优点
1.  单一职责，组织特定状态的code到一个独立的class
2.  开闭原则，引入新的状态不会破坏已经存在的code
3. 通过移除庞大的状态机条件，简化了context的code

##缺点
虽然状态模式以context的方法的形式减少了条件分支，但是引入了额外的state对象，但是这也不算是什么问题






![eberhard grossgasteiger](https://images.unsplash.com/photo-1571217668979-f46db8864f75?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80 "ristina Gottardi")End
