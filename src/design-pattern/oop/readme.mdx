###OOP概念
> 将数据和数据相关的行为封装到一个叫作object的特殊绑定里，
而这对象则是从叫作class的模板构建的。
----
存储在对象field的数据叫做state，对象的方法叫做行为。

class像是蓝图定义了对象的结构


subclass可以继承superclass的state和behavior，只需要定义
自己特殊的state和bahavior。也可以替换和强化父类的behavior。


OOP的四个支柱：
1.抽象
  塑造在特定环境下的对象的state和behaviors。比如飞机类，在飞行模拟器
  程序和航班预订程序里，定义的属性是不一样的。
2.封装
  是指对象隐藏自身的一些状态和行为，只暴露有限的接口给其他对象。
  比如启动汽车，你只需要扭一下钥匙，并不需要你去接通电源。
  interface和abstract class/methods都是基于抽象和封装的。
  interface定义对象之间的约定，所以interface只关注对象的行为，
  而开发者不在interface里声明field
3.继承
  是指在在已有的class上建立新的class。好处就是code reuse。
  缺点是不能隐藏已经在父类里声明的方法，必须实现可能无意义的
  父类抽象方法。
4.多态
  检测对象的真实类，即便在当前环境下不知道对象的真正类型，
  也能调用它的实现

>多数编程语言子类只能继承一个父类，任何一个类都可以实现多个接口。


对象之间的关系
1.继承——————▶
2.实现------▷
3.association，使用/交互/通信 ——————＞
4.dependency ------＞改一个影响另一个
5.composition ◆————＞一个由另外一个组成
6.aggregation ♢————＞一个引用了另外一个

###UML基础
- 带有空三角和实线的箭头使用表明继承关系的，经常由subclass指向superclass;
- 带有实线的简单箭头表明一个对象使用另一个对象，从对象指向被使用的对象；
  双向则是两端的箭头都有一个点
- 带有空三尖角和虚线的箭头表明的是实现接口，指向接口；
- 带有虚线的简单箭头表明依赖关系
- 带有实菱形开头实线连接的简单箭头表示组合关系
- 带有空菱形开头实线连接的简单箭头表示聚合关系

###设计模式
软件设计时常见问题的解决方案。

设计模式与算法都是某些问题的方案
但是算法定义的是到达目标的动作，模式则是高级方案描述。

算法就像是烹饪秘籍；模式就像是菜谱。

模式主要分为三种：
1. 创建模式(creational),提供对象创建机制增加code的灵活性
  和已有code复用性。
2. 结构模式(structural),解释如何去组装对象和类到更大的结构里，
  同时保持结构的灵活和高效。
3. 行为模式(behavioral),负责对象之间的责任分配和有效通信的。

###软件设计原则
好的设计的特性
1. code reuse
  开发任何的软件，成本和时间是两个最有价值的标准。更少的时间，
  意味着先于对手进入市场。更少的成本意味着有更多的钱用于营销，
  以发掘更多的潜在用户。
  > 破坏代码复用的情况：
    1. 组件之间紧密耦合
    2. 依赖实体类而不是interface
    3. hardcoded 操作
  复用的代价就是组件可能会变得更复杂。
  复用的三个级别：（进化顺序）
    1. 最低级，类/类库，容器
    2. 中级，模式
    3. 最高级，framework
2. extensibility
  变化才是程序生活中唯一不变的事情。
  1. windows的游戏，可能要支持macos
  2. GUI框架使用的方形按钮，但是后续圆钮成了趋势
  3. 设计了一个非常好的电商架构，但是后续要求接收手机订单
  变化的几个原因：
  1. 开始解决问题的时候，我们已经理解了问题。通常完成了app的
    一版之后，你可能准备重写了。这是因为你现在更好的理解了问题
    的多个方面
  2. 无法控制的事情发生了。比如依赖flash的实现，到现代的浏览器上
    就无法使用了
  3. 目标变了。现在版本很好了，但是用户提出了最一开始没有提出的需求
这也是有经验的开发者在设计App架构的时候，试着区提供可能的变化原因。

**如果有人要你改变你app的一些东西，意味着有人在乎你的app**

###设计原则
什么是好的软件设计？如何衡量它的好坏？需要遵循什么实践来达到
这个目的？如何使架构灵活，稳定和易于理解？
> 通用的原则:
  1.封装变化的部分
    识别App的哪些方面是变化的，和不变的隔离开。目的是最小化
    变化带来的影响。

  2.方法级别的封装
    比如销售总额(包含税)的计算方法，使用税率的地方就可以单独在
    抽离到函数里，后续更复杂了的话可以抽到class里
  3.类级别的封装
    一个方法过去只是做一个简单的事情，随着时间承担了越来越多
    的责任。新加的行为带有自己的辅助fields，最终会模糊了容器类的
    责任。将行为和数据抽离到新的类，使得原来的类简洁清晰
  4.编程面向接口，而不是实现。依赖抽象，而不是实体类
    两个类协作的时候，通常是一个放在另一个里。但是更好的办法是：
     1. 确定下一个对象到底是需要另一个对象的那些方法
     2. 在一个新的接口或者抽象类里,描述这些方法
     3.一个从属类实现这个接口
     4.另一个类不在依赖从属实体类，而是依赖这个接口
     5.组合胜于继承
      1. subclass不能减少superclass的接口，必须实现父类的
        所有抽象方法，即便不使用
      2. 在覆盖方法的时候，需要确保新的行为兼容base one，因为子类对象
        可能会被传递到使用父类的代码里
      3. 破坏superclass的封装，父类的一些细节需要对子类可见
      4. subclass和superclass紧密耦合，任何父类的改变都可能破坏子类的
        功能
      5. 通过继承复用code会导致创建平行继承层级。继承通常是单维度的。但是任何
        需要多维度的时候，就需要创建大量的类的组合，膨胀的class层级size也会
        更大。继承是is a的关系，组合是has a的关系

###SOLID原则
1. **S**ingle Responsibility  单一责任
  class负责功能的一个部分，这个原则的目的是减少复杂性。
  一个class做太多的事情，一旦某个事情改变，就要改变这个
  class。这就有风险破坏类的其他部分。
2.**O**pen/Closed 开闭原则
  class应该为extension开放，但是闭于修改。目的是实现新特性的
  时候，不会破坏已经存在的code。
  > 一个类可以可以被继承，他就是open的。final class就不能被继承，
3.**L**iskov Substitution 利斯科夫替换原则
  继承一个class的时候，在不破坏client code的情况下，
  应该能够传递子类的对象替换掉父类的对象
  > 子类应该兼容父类的行为。在覆盖父类方法的时候，继承
  父类的基本方法而不是完全的替换掉
    替换原则的一些要求：
      1. subclass方法的参数类型应该匹配或者更抽象于
      superclass的方法参数类型
      2.subclass方法的返回类型应该匹配或者子类于superclass
      的返回类型
      3.subclass的方法抛出的异常应该匹配或者子类于base方法
      的异常
      4.subclass不应该强化预检
        父类的方法是要一个int，子类覆盖了这个方法需要的是
        正数，这就强化了预检
      5.subclass不该弱化后检测
        基类的方法原意是关掉所有的数据库connection，但是
        子类却将其改成了连接仍然保留。而用户的愿意是将所有
        的connection关掉
      6.superclass的不变性必须被保留，子类引入新的域和方法
        但是不能破坏父类的
      7.subclass不应该改变superclass的私有域的值，某些
        编程语言可以通过反射访问类的私有成员
4.**I**nterface Segregation
  client不应该被强迫依赖不使用的方法。那就需要将肥interface
  变成细粒度和特定的接口。client应该只实现他们真正需要的方法。
5.**D**ependency Inversion
  高级类不应该依赖低级类。应该都依赖抽象。抽象不依赖细节。细节
  应该依赖抽象
  - 低级类 是指实现基本操作
  - 高级类 包括复杂逻辑---指导低级类做事情
  依赖反转建议改变依赖的方向
   1. 需要描述高级类依赖的低级操作接口，最好的是以业务术语。
    业务逻辑的方法叫做openReport(file),而不是openFile(file)
    的低级操作
   2.高级类依赖于低级接口，而不是实体的低级类
   3.低级类实现这些接口，它们独立于业务逻辑，反转了原始依赖的
   方向
   (低级类依赖高级抽象)




















