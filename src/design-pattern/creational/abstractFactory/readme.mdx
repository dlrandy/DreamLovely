# 设计模式之抽象工厂模式

**抽象工厂模式属于创建型模式**

![markdown](https://images.unsplash.com/photo-1569261995036-70d0dd50be24?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1789&q=80 "
Kevin Mueller")

>  在不指定实体类的情况下，产生一组相关的对象

###生活中例子对比
有一个家具商店模拟器，有几个类组成

1.  相关的products的family，Chair + Sofa + CoffeeTable
2. family变种：现代风，复古风，艺术风
你需要一种方式创建一个独立的家具对象，以致于它们匹配同款家族里的其他对象。
用户也会疯狂的，在接收到不匹配的家具的时候。还有在添加新产品和产品家族的时候，
不想改变已有的代码，也不想因为家具产商的频繁更新产品，而去改变核心code。

##解决方式
抽象工厂模式
1.显示声明某个家族里每个不同产品(chair,sofa, coffe table)的接口
2.所有的产品变种都遵循这个接口，例如所有的chair变量都实现Chair接口
3.声明抽象工厂--一个带有所有产品创建方法的接口(createChair, createSofa,createCoffeTable),这些方法必须返回抽象的产品类型
4.product family变种，基于抽象工厂接口创建独立的工厂类，一个工厂
返回特定种类的产品，比如ModernFactory只返回ModernChair，ModernSofa和
ModernCoffeeTable
5.用户必须通过各自的抽象接口使用工厂和products
6. 如果用户只使用抽象接口，那什么时候创建工厂对象呢？，通常是在App初始化阶段创建的，app需要根据配置或者环境设置选择工厂类型

##组成结构
1. 抽象产品 声明一组不同但是相关的产品--组成产品family
2. 实体产品 抽象产品的实现，必须在给定的分类里实现
3. 抽象工厂 声明一组方法用于创建每一个抽象产品
4. 实体工厂

##什么时候需要使用抽象工厂模式？
1. 在需要使用相关产品的不同家族的时候，但是不想使用这些产品的实体类---因为他们
事先不知道或者你想允许未来扩展

## 实现步骤
1. 整理出不同的产品类型
2. 声明所有产品的类型的抽象产品接口，使得所有试题产品类实现接口
3. 声明抽象工厂接口---所有抽象产品的创建方法
4. 实现一组实体工厂类，每一个都是一个产品类
5. 在app里创建工厂的初始化代码，他应该依赖当前的app配置或者当前环境实现一个实体工厂类，传递这个工厂对象给所有创建产品的class
6. 找到所有的产品构造器的直接调用，并用工厂对象上适当的方法替换


##优点
1. 可以确认工厂里的产品们都是彼此兼容的
2. 可以避免实体产品和用户代码紧耦合
3. 单一职责原则：可以抽离产品创建代码到一个地方，更易维护
4. 开闭原则 引入新的产品不会破坏已经存在的code



##缺点
1. code变得更复杂，因为你需要引入很多新的类和接口实现这个模式

##和其他模式的关系
1. 抽象工厂是基于一组的工厂方法
2. 抽象工厂是facade模式替换，如果只想隐藏子系统的创建方式
3.

![eberhard grossgasteiger](https://images.unsplash.com/photo-1569196769169-148d853ee706?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=564&q=80 "eberhard grossgasteiger")End











