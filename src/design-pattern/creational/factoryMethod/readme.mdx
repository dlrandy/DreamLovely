# 设计模式之工厂方法模式

**工厂方法模式属于创建型模式**

![markdown](https://images.unsplash.com/photo-1569261995036-70d0dd50be24?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1789&q=80 "
Kevin Mueller")

> 在父类提供创建对象的接口，子类可以修改将要创建对象的类型

###生活中例子对比
比如你创建了一个物流的app，只支持卡车运输。那么物流的运输逻辑会与卡车类耦合，
大多数的逻辑或者卡车相关。但是后来app很好用，需要加入轮船运输，但是当前的code
已经和卡车类严重耦合了。加入轮船类就要修改整个的code。那么再考虑添加飞机运输的情况呢？
> 工厂方法的处理模式使用特殊的工厂方法替换直接的对象创建(new Obejct)，当然
工厂里也会使用new 创建对象，只不过是工厂方法返回对象。这看起来好像没什么意义，
只不过是将constructor的调用移动到程序的另一个地方。但是这样的设计可以让我们在
子类中覆盖工厂方法，改变方法返回的对象的class。
这里有一个限制就是只要返回的对象遵循同一个基类或者接口，子类就可以返回不同
类型的对象，基类的工厂方法里应该有它的返回类型作为接口。
> 软件公司招聘程序员，但是要的是code

###工厂方法的结构
1. Product声明接口，通用于所有的creator及其子类
2. Concrete Product 提供Product接口的不同实现
3. Creator声明工厂方法返回不同的Product
4. Concrete Creator覆盖基本的工厂方法

##什么时候需要使用工厂方法模式？
1. 事先不知道要使用对象的准确类型和依赖的情况
	工厂方法将product的构建code和使用product的code分离，更易于扩展
	product的构建code。
2. 给库或者框架使用者提供一种方式来扩展内部组件的情况
	继承是最简单的扩展库/框架行为的方式。但是库/框架如何认识到你扩展的
	组件呢？
	答案就是将框架里构建组件的code锁入到一个单独的工厂方法里，让其他人
	覆盖这个方法来扩展组件自身。
3. 想复用已经存在的对象，而不是每次创建新的对象，来节省系统资源的情况


## 实现步骤
1. 使得所有的products遵循同样接口product，接口应该声明一些有意义的方法
2. 在creator类里添加一个空的工厂方法，它的返回类型应该匹配product接口
3. 在creator代码里找到所有的product构造器，一个接一个的使用工厂方法替换
	，同时将product的创建代码添加到工厂方法里
4. 为工厂方法里列着的每种product，创建一系列creator 子类，并在子类里覆盖
	工厂方法
5. 如果有太多的product类型，创建所有的子类是没有意义的，可以在子类里复用基类的
	控制参数
6. 所有的抽离之后，基类的工厂方法如果是空的，可以让其成为抽象方法。如果非空
	可以作为方法的默认行为

##优点
1. 避免了creator和实体product的耦合
2. 单一职责原则。product的创建code移动到程序的一处
3. 开闭原则，引入新的product类型，不会破坏已经存在的code


##缺点
1. code变得更复杂，因为你需要引入很多新的类实现这个模式

##和其他模式的关系
1. 很多设计最开始使用工厂方法(不复杂更好定义)，逐步向抽象工厂，原型模式，
	Builder(更灵活，更复杂)进化。
2. 抽象工厂通常基于一组工厂方法，但是也可以使用Prototype在这些class里组合方法
3. 工厂方法和iterator一起使用，可以让子类集合返回不同类型的iterators
4. Prototype不是基于继承的，所以没有缺点。但是它需要被复制对象复杂的初始化。
	工厂方法基于继承，不需要初始化
5. 工厂方法是特殊的模板方法，工厂方法也可以作为模板方法里的一个步骤

![eberhard grossgasteiger](https://images.unsplash.com/photo-1569196769169-148d853ee706?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=564&q=80 "eberhard grossgasteiger")End











