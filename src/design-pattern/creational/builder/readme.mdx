# 设计模式之构建者模式

**构建模式属于创建型模式**

![markdown](https://images.unsplash.com/photo-1569261995036-70d0dd50be24?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1789&q=80 "
Kevin Mueller")

> 构建者是一步一步的构造复杂对象，可以在使用同一个构造代码产生某个对象的不同的类型及其描述。

###生活中的对比
> 比如房子，有的有车库，有的有泳池，有的有花园，当然也可能都有。
创建一个简单的房子，可能要四周墙，地板，门，一对窗户，屋顶。但是想要一个
更大更亮，且带有花园，以及其他好的设施(供暖，排水，供电等)

1. 当然可以继承简单的房子类，然后创建各种不同组合的房子子类；
  但是会有大量的子类。
2. 也可以向简单房子类了提供各种不同的参数，但是很多参数并不会用到，而且构造器的
  调用很难看

### 构建者是如何工作的？
构建者模式建议抽离对象的构造代码到 class house 的外部，移到所谓的builders的独立对象里。
> 将对象的创建抽离到一系列的步骤里。为了创建对象，需要在builder对象上执行一系列步骤。当然可以不调用所有的步骤。某些构造步骤可能需要不同的实现。这种情况可以创建不同的builder class，以不同的方式实现同一系列的构建步骤。

###可选的Director
可以进一步的抽离一系列的builder的步骤调用到独立的class(Director)里。Director
定义构建步骤的顺序，而builder提供这些步骤的实现。
> Director类不是必须的，使用者可以直接以特定的顺序调用构建步骤。但是Director类
会是放置不同的构造路径的最佳场所，以至于在不同的程序中复用它们。此外，
Director完全隐藏了产品构造的实现细节。使用者只需要将builder和director进行关联，
使用director运行构造，并从builder里拿到结果。


###builder结构
1.bulider接口声明所有builder实体共有的构建步骤
2.Concrete Builders提供不同的构建步骤的实现，产生的产品可以不遵循通用的接口
3.products 最终的产品
4.Director定义构建步骤的调用顺序，可以创建和不用products的特殊的配置
5.client 将builder和director进行关联，director使用builder进一步构建


##什么时候需要使用builder模式？
1. 剔除伸缩式(大量的可选参数)的构造器，这种情况也可以使用重载
2. code需要创建某产品不同的描述的时候
	在者设计相似的步骤但是细节不同的产品描述的时候。 基本的builder接口定义所有可能的构造步骤，实体的builder实现这些步骤来构建对象的特定描述。同时director管理者构建的顺序。
3. 使用builder创建组合树或者其他复杂对象
	builder一步一步的构建产品，但是可以在不破坏最终产品的情况下推迟某些步骤的执行。在构建对象树的时候，可以递归执行。

## 实现步骤
1. 明确通用的所有的构建步骤
2. 在基础的builder接口里声明这些步骤
3. 创建实体builder显示实现这些步骤
4. 创建director类，封装构建不同产品的不同步骤
5. 创建Builder和Director对象，在构建开始之前，将builder传到Director
6. 如果所有的产品遵循同一个接口那么直接从Director里获取，否则从builder里获取


##优点
1. 一步一步的构建对象，推迟构建步骤或者递归的运行步骤
2.在构建产品的不同描述的时候，复用相同的构建步骤
3. 单一责任原则，将复杂的创建code和product的业务逻辑分离


##缺点
因为需要很多的新类，code的复杂性增加了

##和其他模式的关系
1. 桥接， 状态， 策略都有相似的结构。都是基于组合的，并将工作代理给其他的对象。但是解决的是不同的问题
2. 命令模式和策略也相似，因为都是用一些动作参数化一个对象。三十

![eberhard grossgasteiger](https://images.unsplash.com/photo-1569196769169-148d853ee706?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=564&q=80 "eberhard grossgasteiger")End
