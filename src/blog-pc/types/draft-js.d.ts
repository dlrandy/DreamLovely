export namespace AtomicBlockUtils {
  function insertAtomicBlock(editorState: any, entityKey: any, character: any): any;
  function moveAtomicBlock(editorState: any, atomicBlock: any, targetRange: any, insertionMode: any): any;
}
export namespace BlockMapBuilder {
  function createFromArray(blocks: any): any;
}
export class CharacterMetadata {
  static applyEntity(record: any, entityKey: any): any;
  static applyStyle(record: any, style: any): any;
  static create(config: any): any;
  static removeStyle(record: any, style: any): any;
  constructor(...args: any[]);
  asImmutable(): any;
  asMutable(): any;
  butLast(): any;
  chain(mapper: any, context: any): any;
  clear(): any;
  concat(...args: any[]): any;
  contains(searchValue: any): any;
  count(predicate: any, context: any): any;
  countBy(grouper: any, context: any): any;
  deleteIn(keyPath: any): any;
  entries(): any;
  entrySeq(): any;
  equals(other: any): any;
  every(predicate: any, context: any): any;
  filter(predicate: any, context: any): any;
  filterNot(predicate: any, context: any): any;
  find(predicate: any, context: any, notSetValue: any): any;
  findEntry(predicate: any, context: any): any;
  findKey(predicate: any, context: any): any;
  findLast(predicate: any, context: any, notSetValue: any): any;
  findLastEntry(predicate: any, context: any): any;
  findLastKey(predicate: any, context: any): any;
  first(): any;
  flatMap(mapper: any, context: any): any;
  flatten(depth: any): any;
  flip(): any;
  forEach(sideEffect: any, context: any): any;
  fromEntrySeq(): any;
  get(k: any, notSetValue: any): any;
  getEntity(): any;
  getIn(searchKeyPath: any, notSetValue: any): any;
  getStyle(): any;
  groupBy(grouper: any, context: any): any;
  has(k: any): any;
  hasIn(searchKeyPath: any): any;
  hasStyle(style: any): any;
  hashCode(): any;
  includes(searchValue: any): any;
  inspect(): any;
  isEmpty(): any;
  isSubset(iter: any): any;
  isSuperset(iter: any): any;
  join(separator: any): any;
  keyOf(searchValue: any): any;
  keySeq(): any;
  keys(): any;
  last(): any;
  lastKeyOf(searchValue: any): any;
  map(mapper: any, context: any): any;
  mapEntries(mapper: any, context: any): any;
  mapKeys(mapper: any, context: any): any;
  max(comparator: any): any;
  maxBy(mapper: any, comparator: any): any;
  merge(...args: any[]): any;
  mergeDeep(...args: any[]): any;
  mergeDeepIn(keyPath: any, ...args: any[]): any;
  mergeDeepWith(merger: any, ...args: any[]): any;
  mergeIn(keyPath: any, ...args: any[]): any;
  mergeWith(merger: any, ...args: any[]): any;
  min(comparator: any): any;
  minBy(mapper: any, comparator: any): any;
  reduce(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  reduceRight(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  remove(k: any): any;
  removeIn(keyPath: any): any;
  rest(): any;
  reverse(): any;
  set(k: any, v: any): any;
  setIn(keyPath: any, v: any): any;
  skip(amount: any): any;
  skipLast(amount: any): any;
  skipUntil(predicate: any, context: any): any;
  skipWhile(predicate: any, context: any): any;
  slice(begin: any, end: any): any;
  some(predicate: any, context: any): any;
  sort(comparator: any): any;
  sortBy(mapper: any, comparator: any): any;
  take(amount: any): any;
  takeLast(amount: any): any;
  takeUntil(predicate: any, context: any): any;
  takeWhile(predicate: any, context: any): any;
  toArray(): any;
  toIndexedSeq(): any;
  toJS(): any;
  toJSON(): any;
  toKeyedSeq(): any;
  toList(): any;
  toMap(): any;
  toObject(): any;
  toOrderedMap(): any;
  toOrderedSet(): any;
  toSeq(): any;
  toSet(): any;
  toSetSeq(): any;
  toSource(): any;
  toStack(): any;
  update(k: any, notSetValue: any, updater: any, ...args: any[]): any;
  updateIn(keyPath: any, notSetValue: any, updater: any): any;
  valueSeq(): any;
  values(): any;
  wasAltered(): any;
  withMutations(fn: any): any;
}
export namespace CharacterMetadata {
  const EMPTY: {
    "@@__IMMUTABLE_ITERABLE__@@": boolean;
    "@@__IMMUTABLE_KEYED__@@": boolean;
    asImmutable: Function;
    asMutable: Function;
    butLast: Function;
    chain: Function;
    clear: Function;
    concat: Function;
    contains: Function;
    count: Function;
    countBy: Function;
    delete: Function;
    deleteIn: Function;
    entity: any;
    entries: Function;
    entrySeq: Function;
    equals: Function;
    every: Function;
    filter: Function;
    filterNot: Function;
    find: Function;
    findEntry: Function;
    findKey: Function;
    findLast: Function;
    findLastEntry: Function;
    findLastKey: Function;
    first: Function;
    flatMap: Function;
    flatten: Function;
    flip: Function;
    forEach: Function;
    fromEntrySeq: Function;
    get: Function;
    getEntity: Function;
    getIn: Function;
    getStyle: Function;
    groupBy: Function;
    has: Function;
    hasIn: Function;
    hasStyle: Function;
    hashCode: Function;
    includes: Function;
    inspect: Function;
    isEmpty: Function;
    isSubset: Function;
    isSuperset: Function;
    join: Function;
    keyOf: Function;
    keySeq: Function;
    keys: Function;
    last: Function;
    lastKeyOf: Function;
    length: any;
    map: Function;
    mapEntries: Function;
    mapKeys: Function;
    max: Function;
    maxBy: Function;
    merge: Function;
    mergeDeep: Function;
    mergeDeepIn: Function;
    mergeDeepWith: Function;
    mergeIn: Function;
    mergeWith: Function;
    min: Function;
    minBy: Function;
    reduce: Function;
    reduceRight: Function;
    remove: Function;
    removeIn: Function;
    rest: Function;
    reverse: Function;
    set: Function;
    setIn: Function;
    size: number;
    skip: Function;
    skipLast: Function;
    skipUntil: Function;
    skipWhile: Function;
    slice: Function;
    some: Function;
    sort: Function;
    sortBy: Function;
    style: any;
    take: Function;
    takeLast: Function;
    takeUntil: Function;
    takeWhile: Function;
    toArray: Function;
    toIndexedSeq: Function;
    toJS: Function;
    toJSON: Function;
    toKeyedSeq: Function;
    toList: Function;
    toMap: Function;
    toObject: Function;
    toOrderedMap: Function;
    toOrderedSet: Function;
    toSeq: Function;
    toSet: Function;
    toSetSeq: Function;
    toSource: Function;
    toStack: Function;
    update: Function;
    updateIn: Function;
    valueSeq: Function;
    values: Function;
    wasAltered: Function;
    withMutations: Function;
  };
}
export class CompositeDecorator {
  constructor(decorators: any);
  getComponentForKey(key: any): any;
  getDecorations(block: any, contentState: any): any;
  getPropsForKey(key: any): any;
}
export class ContentBlock {
  constructor(config: any);
  asImmutable(): any;
  asMutable(): any;
  butLast(): any;
  chain(mapper: any, context: any): any;
  clear(): any;
  concat(...args: any[]): any;
  contains(searchValue: any): any;
  count(predicate: any, context: any): any;
  countBy(grouper: any, context: any): any;
  deleteIn(keyPath: any): any;
  entries(): any;
  entrySeq(): any;
  equals(other: any): any;
  every(predicate: any, context: any): any;
  filter(predicate: any, context: any): any;
  filterNot(predicate: any, context: any): any;
  find(predicate: any, context: any, notSetValue: any): any;
  findEntityRanges(filterFn: any, callback: any): void;
  findEntry(predicate: any, context: any): any;
  findKey(predicate: any, context: any): any;
  findLast(predicate: any, context: any, notSetValue: any): any;
  findLastEntry(predicate: any, context: any): any;
  findLastKey(predicate: any, context: any): any;
  findStyleRanges(filterFn: any, callback: any): void;
  first(): any;
  flatMap(mapper: any, context: any): any;
  flatten(depth: any): any;
  flip(): any;
  forEach(sideEffect: any, context: any): any;
  fromEntrySeq(): any;
  get(k: any, notSetValue: any): any;
  getCharacterList(): any;
  getData(): any;
  getDepth(): any;
  getEntityAt(offset: any): any;
  getIn(searchKeyPath: any, notSetValue: any): any;
  getInlineStyleAt(offset: any): any;
  getKey(): any;
  getLength(): any;
  getText(): any;
  getType(): any;
  groupBy(grouper: any, context: any): any;
  has(k: any): any;
  hasIn(searchKeyPath: any): any;
  hashCode(): any;
  includes(searchValue: any): any;
  inspect(): any;
  isEmpty(): any;
  isSubset(iter: any): any;
  isSuperset(iter: any): any;
  join(separator: any): any;
  keyOf(searchValue: any): any;
  keySeq(): any;
  keys(): any;
  last(): any;
  lastKeyOf(searchValue: any): any;
  map(mapper: any, context: any): any;
  mapEntries(mapper: any, context: any): any;
  mapKeys(mapper: any, context: any): any;
  max(comparator: any): any;
  maxBy(mapper: any, comparator: any): any;
  merge(...args: any[]): any;
  mergeDeep(...args: any[]): any;
  mergeDeepIn(keyPath: any, ...args: any[]): any;
  mergeDeepWith(merger: any, ...args: any[]): any;
  mergeIn(keyPath: any, ...args: any[]): any;
  mergeWith(merger: any, ...args: any[]): any;
  min(comparator: any): any;
  minBy(mapper: any, comparator: any): any;
  reduce(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  reduceRight(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  remove(k: any): any;
  removeIn(keyPath: any): any;
  rest(): any;
  reverse(): any;
  set(k: any, v: any): any;
  setIn(keyPath: any, v: any): any;
  skip(amount: any): any;
  skipLast(amount: any): any;
  skipUntil(predicate: any, context: any): any;
  skipWhile(predicate: any, context: any): any;
  slice(begin: any, end: any): any;
  some(predicate: any, context: any): any;
  sort(comparator: any): any;
  sortBy(mapper: any, comparator: any): any;
  take(amount: any): any;
  takeLast(amount: any): any;
  takeUntil(predicate: any, context: any): any;
  takeWhile(predicate: any, context: any): any;
  toArray(): any;
  toIndexedSeq(): any;
  toJS(): any;
  toJSON(): any;
  toKeyedSeq(): any;
  toList(): any;
  toMap(): any;
  toObject(): any;
  toOrderedMap(): any;
  toOrderedSet(): any;
  toSeq(): any;
  toSet(): any;
  toSetSeq(): any;
  toSource(): any;
  toStack(): any;
  update(k: any, notSetValue: any, updater: any, ...args: any[]): any;
  updateIn(keyPath: any, notSetValue: any, updater: any): any;
  valueSeq(): any;
  values(): any;
  wasAltered(): any;
  withMutations(fn: any): any;
}
export class ContentState {
  static createFromBlockArray(blocks: any, entityMap: any): any;
  static createFromText(text: any, ...args: any[]): any;
  constructor(...args: any[]);
  addEntity(instance: any): any;
  asImmutable(): any;
  asMutable(): any;
  butLast(): any;
  chain(mapper: any, context: any): any;
  clear(): any;
  concat(...args: any[]): any;
  contains(searchValue: any): any;
  count(predicate: any, context: any): any;
  countBy(grouper: any, context: any): any;
  createEntity(type: any, mutability: any, data: any): any;
  deleteIn(keyPath: any): any;
  entries(): any;
  entrySeq(): any;
  equals(other: any): any;
  every(predicate: any, context: any): any;
  filter(predicate: any, context: any): any;
  filterNot(predicate: any, context: any): any;
  find(predicate: any, context: any, notSetValue: any): any;
  findEntry(predicate: any, context: any): any;
  findKey(predicate: any, context: any): any;
  findLast(predicate: any, context: any, notSetValue: any): any;
  findLastEntry(predicate: any, context: any): any;
  findLastKey(predicate: any, context: any): any;
  first(): any;
  flatMap(mapper: any, context: any): any;
  flatten(depth: any): any;
  flip(): any;
  forEach(sideEffect: any, context: any): any;
  fromEntrySeq(): any;
  get(k: any, notSetValue: any): any;
  getBlockAfter(key: any): any;
  getBlockBefore(key: any): any;
  getBlockForKey(key: any): any;
  getBlockMap(): any;
  getBlocksAsArray(): any;
  getEntity(key: any): any;
  getEntityMap(): any;
  getFirstBlock(): any;
  getIn(searchKeyPath: any, notSetValue: any): any;
  getKeyAfter(key: any): any;
  getKeyBefore(key: any): any;
  getLastBlock(): any;
  getLastCreatedEntityKey(): any;
  getPlainText(delimiter: any): any;
  getSelectionAfter(): any;
  getSelectionBefore(): any;
  groupBy(grouper: any, context: any): any;
  has(k: any): any;
  hasIn(searchKeyPath: any): any;
  hasText(): any;
  hashCode(): any;
  includes(searchValue: any): any;
  inspect(): any;
  isEmpty(): any;
  isSubset(iter: any): any;
  isSuperset(iter: any): any;
  join(separator: any): any;
  keyOf(searchValue: any): any;
  keySeq(): any;
  keys(): any;
  last(): any;
  lastKeyOf(searchValue: any): any;
  map(mapper: any, context: any): any;
  mapEntries(mapper: any, context: any): any;
  mapKeys(mapper: any, context: any): any;
  max(comparator: any): any;
  maxBy(mapper: any, comparator: any): any;
  merge(...args: any[]): any;
  mergeDeep(...args: any[]): any;
  mergeDeepIn(keyPath: any, ...args: any[]): any;
  mergeDeepWith(merger: any, ...args: any[]): any;
  mergeEntityData(key: any, toMerge: any): any;
  mergeIn(keyPath: any, ...args: any[]): any;
  mergeWith(merger: any, ...args: any[]): any;
  min(comparator: any): any;
  minBy(mapper: any, comparator: any): any;
  reduce(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  reduceRight(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  remove(k: any): any;
  removeIn(keyPath: any): any;
  replaceEntityData(key: any, newData: any): any;
  rest(): any;
  reverse(): any;
  set(k: any, v: any): any;
  setIn(keyPath: any, v: any): any;
  skip(amount: any): any;
  skipLast(amount: any): any;
  skipUntil(predicate: any, context: any): any;
  skipWhile(predicate: any, context: any): any;
  slice(begin: any, end: any): any;
  some(predicate: any, context: any): any;
  sort(comparator: any): any;
  sortBy(mapper: any, comparator: any): any;
  take(amount: any): any;
  takeLast(amount: any): any;
  takeUntil(predicate: any, context: any): any;
  takeWhile(predicate: any, context: any): any;
  toArray(): any;
  toIndexedSeq(): any;
  toJS(): any;
  toJSON(): any;
  toKeyedSeq(): any;
  toList(): any;
  toMap(): any;
  toObject(): any;
  toOrderedMap(): any;
  toOrderedSet(): any;
  toSeq(): any;
  toSet(): any;
  toSetSeq(): any;
  toSource(): any;
  toStack(): any;
  update(k: any, notSetValue: any, updater: any, ...args: any[]): any;
  updateIn(keyPath: any, notSetValue: any, updater: any): any;
  valueSeq(): any;
  values(): any;
  wasAltered(): any;
  withMutations(fn: any): any;
}
export const DefaultDraftBlockRenderMap: {
  "@@__IMMUTABLE_ITERABLE__@@": boolean;
  "@@__IMMUTABLE_KEYED__@@": boolean;
  "@@__IMMUTABLE_MAP__@@": boolean;
  asImmutable: Function;
  asMutable: Function;
  butLast: Function;
  chain: Function;
  clear: Function;
  concat: Function;
  contains: Function;
  count: Function;
  countBy: Function;
  delete: Function;
  deleteIn: Function;
  entries: Function;
  entrySeq: Function;
  equals: Function;
  every: Function;
  filter: Function;
  filterNot: Function;
  find: Function;
  findEntry: Function;
  findKey: Function;
  findLast: Function;
  findLastEntry: Function;
  findLastKey: Function;
  first: Function;
  flatMap: Function;
  flatten: Function;
  flip: Function;
  forEach: Function;
  fromEntrySeq: Function;
  get: Function;
  getIn: Function;
  groupBy: Function;
  has: Function;
  hasIn: Function;
  hashCode: Function;
  includes: Function;
  inspect: Function;
  isEmpty: Function;
  isSubset: Function;
  isSuperset: Function;
  join: Function;
  keyOf: Function;
  keySeq: Function;
  keys: Function;
  last: Function;
  lastKeyOf: Function;
  length: any;
  map: Function;
  mapEntries: Function;
  mapKeys: Function;
  max: Function;
  maxBy: Function;
  merge: Function;
  mergeDeep: Function;
  mergeDeepIn: Function;
  mergeDeepWith: Function;
  mergeIn: Function;
  mergeWith: Function;
  min: Function;
  minBy: Function;
  reduce: Function;
  reduceRight: Function;
  remove: Function;
  removeIn: Function;
  rest: Function;
  reverse: Function;
  set: Function;
  setIn: Function;
  size: number;
  skip: Function;
  skipLast: Function;
  skipUntil: Function;
  skipWhile: Function;
  slice: Function;
  some: Function;
  sort: Function;
  sortBy: Function;
  take: Function;
  takeLast: Function;
  takeUntil: Function;
  takeWhile: Function;
  toArray: Function;
  toIndexedSeq: Function;
  toJS: Function;
  toJSON: Function;
  toKeyedSeq: Function;
  toList: Function;
  toMap: Function;
  toObject: Function;
  toOrderedMap: Function;
  toOrderedSet: Function;
  toSeq: Function;
  toSet: Function;
  toSetSeq: Function;
  toSource: Function;
  toStack: Function;
  update: Function;
  updateIn: Function;
  valueSeq: Function;
  values: Function;
  wasAltered: Function;
  withMutations: Function;
};
export const DefaultDraftInlineStyle: {
  BOLD: {
    fontWeight: string;
  };
  CODE: {
    fontFamily: string;
    wordWrap: string;
  };
  ITALIC: {
    fontStyle: string;
  };
  STRIKETHROUGH: {
    textDecoration: string;
  };
  UNDERLINE: {
    textDecoration: string;
  };
};
export class Editor {
  props: any;
  constructor(props: any);
  componentDidMount(): void;
  componentDidUpdate(): void;
  componentWillUpdate(nextProps: any): void;
  forceUpdate(callback: any): void;
  render(): any;
  setState(partialState: any, callback: any): void;
}
export namespace Editor {
  namespace defaultProps {
    const blockRenderMap: {
      "@@__IMMUTABLE_ITERABLE__@@": boolean;
      "@@__IMMUTABLE_KEYED__@@": boolean;
      "@@__IMMUTABLE_MAP__@@": boolean;
      asImmutable: Function;
      asMutable: Function;
      butLast: Function;
      chain: Function;
      clear: Function;
      concat: Function;
      contains: Function;
      count: Function;
      countBy: Function;
      delete: Function;
      deleteIn: Function;
      entries: Function;
      entrySeq: Function;
      equals: Function;
      every: Function;
      filter: Function;
      filterNot: Function;
      find: Function;
      findEntry: Function;
      findKey: Function;
      findLast: Function;
      findLastEntry: Function;
      findLastKey: Function;
      first: Function;
      flatMap: Function;
      flatten: Function;
      flip: Function;
      forEach: Function;
      fromEntrySeq: Function;
      get: Function;
      getIn: Function;
      groupBy: Function;
      has: Function;
      hasIn: Function;
      hashCode: Function;
      includes: Function;
      inspect: Function;
      isEmpty: Function;
      isSubset: Function;
      isSuperset: Function;
      join: Function;
      keyOf: Function;
      keySeq: Function;
      keys: Function;
      last: Function;
      lastKeyOf: Function;
      length: any;
      map: Function;
      mapEntries: Function;
      mapKeys: Function;
      max: Function;
      maxBy: Function;
      merge: Function;
      mergeDeep: Function;
      mergeDeepIn: Function;
      mergeDeepWith: Function;
      mergeIn: Function;
      mergeWith: Function;
      min: Function;
      minBy: Function;
      reduce: Function;
      reduceRight: Function;
      remove: Function;
      removeIn: Function;
      rest: Function;
      reverse: Function;
      set: Function;
      setIn: Function;
      size: number;
      skip: Function;
      skipLast: Function;
      skipUntil: Function;
      skipWhile: Function;
      slice: Function;
      some: Function;
      sort: Function;
      sortBy: Function;
      take: Function;
      takeLast: Function;
      takeUntil: Function;
      takeWhile: Function;
      toArray: Function;
      toIndexedSeq: Function;
      toJS: Function;
      toJSON: Function;
      toKeyedSeq: Function;
      toList: Function;
      toMap: Function;
      toObject: Function;
      toOrderedMap: Function;
      toOrderedSet: Function;
      toSeq: Function;
      toSet: Function;
      toSetSeq: Function;
      toSource: Function;
      toStack: Function;
      update: Function;
      updateIn: Function;
      valueSeq: Function;
      values: Function;
      wasAltered: Function;
      withMutations: Function;
    };
    function blockRendererFn(): any;
    function blockStyleFn(): any;
    function keyBindingFn(e: any): any;
    const readOnly: boolean;
    const spellCheck: boolean;
    const stripPastedStyles: boolean;
  }
}
export class EditorBlock {
  constructor(...args: any[]);
  componentDidMount(): void;
  forceUpdate(callback: any): void;
  render(): any;
  setState(partialState: any, callback: any): void;
  shouldComponentUpdate(nextProps: any): any;
}
export class EditorState {
  static acceptSelection(editorState: any, selection: any): any;
  static create(config: any): any;
  static createEmpty(decorator: any): any;
  static createWithContent(contentState: any, decorator: any): any;
  static forceSelection(editorState: any, selection: any): any;
  static moveFocusToEnd(editorState: any): any;
  static moveSelectionToEnd(editorState: any): any;
  static push(editorState: any, contentState: any, changeType: any): any;
  static redo(editorState: any): any;
  static set(editorState: any, put: any): any;
  static setInlineStyleOverride(editorState: any, inlineStyleOverride: any): any;
  static undo(editorState: any): any;
  constructor(immutable: any);
  getAllowUndo(): any;
  getBlockTree(blockKey: any): any;
  getCurrentContent(): any;
  getCurrentInlineStyle(): any;
  getDecorator(): any;
  getDirectionMap(): any;
  getImmutable(): any;
  getInlineStyleOverride(): any;
  getLastChangeType(): any;
  getNativelyRenderedContent(): any;
  getRedoStack(): any;
  getSelection(): any;
  getUndoStack(): any;
  isInCompositionMode(): any;
  isSelectionAtEndOfContent(): any;
  isSelectionAtStartOfContent(): any;
  mustForceSelection(): any;
  toJS(): any;
}
export namespace Entity {
  function add(instance: any): any;
  function create(type: any, mutability: any, data: any): any;
  function get(key: any): any;
  function getLastCreatedEntityKey(): any;
  function mergeData(key: any, toMerge: any): any;
  function replaceData(key: any, newData: any): any;
}
export class EntityInstance {
  constructor(...args: any[]);
  asImmutable(): any;
  asMutable(): any;
  butLast(): any;
  chain(mapper: any, context: any): any;
  clear(): any;
  concat(...args: any[]): any;
  contains(searchValue: any): any;
  count(predicate: any, context: any): any;
  countBy(grouper: any, context: any): any;
  deleteIn(keyPath: any): any;
  entries(): any;
  entrySeq(): any;
  equals(other: any): any;
  every(predicate: any, context: any): any;
  filter(predicate: any, context: any): any;
  filterNot(predicate: any, context: any): any;
  find(predicate: any, context: any, notSetValue: any): any;
  findEntry(predicate: any, context: any): any;
  findKey(predicate: any, context: any): any;
  findLast(predicate: any, context: any, notSetValue: any): any;
  findLastEntry(predicate: any, context: any): any;
  findLastKey(predicate: any, context: any): any;
  first(): any;
  flatMap(mapper: any, context: any): any;
  flatten(depth: any): any;
  flip(): any;
  forEach(sideEffect: any, context: any): any;
  fromEntrySeq(): any;
  get(k: any, notSetValue: any): any;
  getData(): any;
  getIn(searchKeyPath: any, notSetValue: any): any;
  getMutability(): any;
  getType(): any;
  groupBy(grouper: any, context: any): any;
  has(k: any): any;
  hasIn(searchKeyPath: any): any;
  hashCode(): any;
  includes(searchValue: any): any;
  inspect(): any;
  isEmpty(): any;
  isSubset(iter: any): any;
  isSuperset(iter: any): any;
  join(separator: any): any;
  keyOf(searchValue: any): any;
  keySeq(): any;
  keys(): any;
  last(): any;
  lastKeyOf(searchValue: any): any;
  map(mapper: any, context: any): any;
  mapEntries(mapper: any, context: any): any;
  mapKeys(mapper: any, context: any): any;
  max(comparator: any): any;
  maxBy(mapper: any, comparator: any): any;
  merge(...args: any[]): any;
  mergeDeep(...args: any[]): any;
  mergeDeepIn(keyPath: any, ...args: any[]): any;
  mergeDeepWith(merger: any, ...args: any[]): any;
  mergeIn(keyPath: any, ...args: any[]): any;
  mergeWith(merger: any, ...args: any[]): any;
  min(comparator: any): any;
  minBy(mapper: any, comparator: any): any;
  reduce(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  reduceRight(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  remove(k: any): any;
  removeIn(keyPath: any): any;
  rest(): any;
  reverse(): any;
  set(k: any, v: any): any;
  setIn(keyPath: any, v: any): any;
  skip(amount: any): any;
  skipLast(amount: any): any;
  skipUntil(predicate: any, context: any): any;
  skipWhile(predicate: any, context: any): any;
  slice(begin: any, end: any): any;
  some(predicate: any, context: any): any;
  sort(comparator: any): any;
  sortBy(mapper: any, comparator: any): any;
  take(amount: any): any;
  takeLast(amount: any): any;
  takeUntil(predicate: any, context: any): any;
  takeWhile(predicate: any, context: any): any;
  toArray(): any;
  toIndexedSeq(): any;
  toJS(): any;
  toJSON(): any;
  toKeyedSeq(): any;
  toList(): any;
  toMap(): any;
  toObject(): any;
  toOrderedMap(): any;
  toOrderedSet(): any;
  toSeq(): any;
  toSet(): any;
  toSetSeq(): any;
  toSource(): any;
  toStack(): any;
  update(k: any, notSetValue: any, updater: any, ...args: any[]): any;
  updateIn(keyPath: any, notSetValue: any, updater: any): any;
  valueSeq(): any;
  values(): any;
  wasAltered(): any;
  withMutations(fn: any): any;
}
export namespace KeyBindingUtil {
  function hasCommandModifier(e: any): any;
  function isCtrlKeyCommand(e: any): any;
  function isOptionKeyCommand(e: any): any;
}
export namespace Modifier {
  function applyEntity(contentState: any, selectionState: any, entityKey: any): any;
  function applyInlineStyle(contentState: any, selectionState: any, inlineStyle: any): any;
  function insertText(contentState: any, targetRange: any, text: any, inlineStyle: any, entityKey: any): any;
  function mergeBlockData(contentState: any, selectionState: any, blockData: any): any;
  function moveText(contentState: any, removalRange: any, targetRange: any): any;
  function removeInlineStyle(contentState: any, selectionState: any, inlineStyle: any): any;
  function removeRange(contentState: any, rangeToRemove: any, removalDirection: any): any;
  function replaceText(contentState: any, rangeToReplace: any, text: any, inlineStyle: any, entityKey: any): any;
  function replaceWithFragment(contentState: any, targetRange: any, fragment: any): any;
  function setBlockData(contentState: any, selectionState: any, blockData: any): any;
  function setBlockType(contentState: any, selectionState: any, blockType: any): any;
  function splitBlock(contentState: any, selectionState: any): any;
}
export namespace RichUtils {
  function currentBlockContainsLink(editorState: any): any;
  function getCurrentBlockType(editorState: any): any;
  function getDataObjectForLinkURL(uri: any): any;
  function handleKeyCommand(editorState: any, command: any): any;
  function insertSoftNewline(editorState: any): any;
  function onBackspace(editorState: any): any;
  function onDelete(editorState: any): any;
  function onTab(event: any, editorState: any, maxDepth: any): any;
  function toggleBlockType(editorState: any, blockType: any): any;
  function toggleCode(editorState: any): any;
  function toggleInlineStyle(editorState: any, inlineStyle: any): any;
  function toggleLink(editorState: any, targetSelection: any, entityKey: any): any;
  function tryToRemoveBlockStyle(editorState: any): any;
}
export class SelectionState {
  static createEmpty(key: any): any;
  constructor(...args: any[]);
  asImmutable(): any;
  asMutable(): any;
  butLast(): any;
  chain(mapper: any, context: any): any;
  clear(): any;
  concat(...args: any[]): any;
  contains(searchValue: any): any;
  count(predicate: any, context: any): any;
  countBy(grouper: any, context: any): any;
  deleteIn(keyPath: any): any;
  entries(): any;
  entrySeq(): any;
  equals(other: any): any;
  every(predicate: any, context: any): any;
  filter(predicate: any, context: any): any;
  filterNot(predicate: any, context: any): any;
  find(predicate: any, context: any, notSetValue: any): any;
  findEntry(predicate: any, context: any): any;
  findKey(predicate: any, context: any): any;
  findLast(predicate: any, context: any, notSetValue: any): any;
  findLastEntry(predicate: any, context: any): any;
  findLastKey(predicate: any, context: any): any;
  first(): any;
  flatMap(mapper: any, context: any): any;
  flatten(depth: any): any;
  flip(): any;
  forEach(sideEffect: any, context: any): any;
  fromEntrySeq(): any;
  get(k: any, notSetValue: any): any;
  getAnchorKey(): any;
  getAnchorOffset(): any;
  getEndKey(): any;
  getEndOffset(): any;
  getFocusKey(): any;
  getFocusOffset(): any;
  getHasFocus(): any;
  getIn(searchKeyPath: any, notSetValue: any): any;
  getIsBackward(): any;
  getStartKey(): any;
  getStartOffset(): any;
  groupBy(grouper: any, context: any): any;
  has(k: any): any;
  hasEdgeWithin(blockKey: any, start: any, end: any): any;
  hasIn(searchKeyPath: any): any;
  hashCode(): any;
  includes(searchValue: any): any;
  inspect(): any;
  isCollapsed(): any;
  isEmpty(): any;
  isSubset(iter: any): any;
  isSuperset(iter: any): any;
  join(separator: any): any;
  keyOf(searchValue: any): any;
  keySeq(): any;
  keys(): any;
  last(): any;
  lastKeyOf(searchValue: any): any;
  map(mapper: any, context: any): any;
  mapEntries(mapper: any, context: any): any;
  mapKeys(mapper: any, context: any): any;
  max(comparator: any): any;
  maxBy(mapper: any, comparator: any): any;
  merge(...args: any[]): any;
  mergeDeep(...args: any[]): any;
  mergeDeepIn(keyPath: any, ...args: any[]): any;
  mergeDeepWith(merger: any, ...args: any[]): any;
  mergeIn(keyPath: any, ...args: any[]): any;
  mergeWith(merger: any, ...args: any[]): any;
  min(comparator: any): any;
  minBy(mapper: any, comparator: any): any;
  reduce(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  reduceRight(reducer: any, initialReduction: any, context: any, ...args: any[]): any;
  remove(k: any): any;
  removeIn(keyPath: any): any;
  rest(): any;
  reverse(): any;
  serialize(): any;
  set(k: any, v: any): any;
  setIn(keyPath: any, v: any): any;
  skip(amount: any): any;
  skipLast(amount: any): any;
  skipUntil(predicate: any, context: any): any;
  skipWhile(predicate: any, context: any): any;
  slice(begin: any, end: any): any;
  some(predicate: any, context: any): any;
  sort(comparator: any): any;
  sortBy(mapper: any, comparator: any): any;
  take(amount: any): any;
  takeLast(amount: any): any;
  takeUntil(predicate: any, context: any): any;
  takeWhile(predicate: any, context: any): any;
  toArray(): any;
  toIndexedSeq(): any;
  toJS(): any;
  toJSON(): any;
  toKeyedSeq(): any;
  toList(): any;
  toMap(): any;
  toObject(): any;
  toOrderedMap(): any;
  toOrderedSet(): any;
  toSeq(): any;
  toSet(): any;
  toSetSeq(): any;
  toSource(): any;
  toStack(): any;
  update(k: any, notSetValue: any, updater: any, ...args: any[]): any;
  updateIn(keyPath: any, notSetValue: any, updater: any): any;
  valueSeq(): any;
  values(): any;
  wasAltered(): any;
  withMutations(fn: any): any;
}
export function convertFromHTML(html: any, ...args: any[]): any;
export function convertFromRaw(rawState: any): any;
export function convertToRaw(contentState: any): any;
export function genKey(): any;
export function getDefaultKeyBinding(e: any): any;
export function getVisibleSelectionRect(global: any): any;
